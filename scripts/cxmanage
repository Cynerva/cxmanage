#!/usr/bin/env python

#Copyright 2012 Calxeda, Inc.  All rights reserved.

"""Command line tool for managing a Calxeda cluster"""

import argparse
import os
import sys

from cxmanage.controller import Controller

def build_parser():
    """setup the argparse parser"""
    parser = argparse.ArgumentParser(
            description='Calxeda Server Management Utility')

    #global arguments
    parser.add_argument('-u', '--user', default='admin',
                        help='Username for login')
    parser.add_argument('-p', '--password', default='admin',
                        help='Password for login')
    parser.add_argument('-a', '--all-nodes', action='store_true',
                        help='Send command to all nodes reported by fabric')
    parser.add_argument('-v', '--verbose', action='store_true',
                        help='Verbose output')
    tftp_type = parser.add_mutually_exclusive_group()
    tftp_type.add_argument('-t', '--tftp',
            help='Connect to remote TFTP server at <ip:port>')
    tftp_type.add_argument('--internal-tftp',
            help='Host an internal TFTP server listening on <ip:port>')

    subparsers = parser.add_subparsers()

    #power command
    power = subparsers.add_parser('power',
                                  help='control a9 power')
    power_subs = power.add_subparsers()

    power_on = power_subs.add_parser('on', help='boot the a9')
    power_on.set_defaults(power_mode='on')

    power_off = power_subs.add_parser('off', help='shut the a9 off')
    power_off.set_defaults(power_mode='off')

    power_reset = power_subs.add_parser('reset', help='reset the a9')
    power_reset.set_defaults(power_mode='reset')

    power_status = power_subs.add_parser('status', help='get a9 power status')
    power_status.set_defaults(power_mode='status')

    power_policy = power_subs.add_parser('policy', help='set a9 power policy')
    power_policy.add_argument('policy', help='Policy to set',
                             choices=['always-on', 'always-off', 'previous'])
    power_policy.set_defaults(power_mode='policy')

    power.set_defaults(func=power_command)

    #mcreset command
    mcreset = subparsers.add_parser('mcreset',
                                  help='reset the management controller')
    mcreset.set_defaults(func=mcreset_command)

    #fwupdate command
    fwupdate = subparsers.add_parser('fwupdate', help='update firmware')

    fwupdate.add_argument('image_type', metavar='IMAGE_TYPE',
                        help='type of image to update',
                        type=lambda string: string.upper(),
                        choices = list(sorted([
                            'DEL',
                            'DEL1',
                            'S2_ELF',
                            'SOC_ELF',
                            'A9_UEFI',
                            'A9_UBOOT',
                            'A9_EXEC',
                            'A9_ELF',
                            'SOCDATA',
                            'DTB',
                            'CDB',
                            'UBOOTENV',
                            'SEL',
                            'BOOT_LOG',
                            'UEFI_ENV',
                            'DIAG_ELF',
                            'SPIF',
                            'PACKAGE'
                        ]))
            )
    fwupdate.add_argument('filename', help='path to file to upload')
    fwupdate.add_argument('--slot', help='Specify slot to update',
                            default='INACTIVE',
                            type=lambda string: string.upper(),
                            choices = list(sorted([
                                'FIRST',
                                'SECOND',
                                'THIRD',
                                'BOTH',
                                'OLDEST',
                                'NEWEST',
                                'INACTIVE'
                            ]))
            )
    fwupdate.add_argument('--no-reset', help='Don\'t reset the MC after updating',
                            default=False, action='store_true')
    simg_args = fwupdate.add_mutually_exclusive_group()
    simg_args.add_argument('--force-simg', help='Force addition of SIMG header',
                            default=False, action='store_true')
    simg_args.add_argument('--skip-simg', help='Skip addition of SIMG header',
                            default=False, action='store_true')
    fwupdate.add_argument('--version', help='Version for SIMG header',
                            default=None, type=int)
    fwupdate.add_argument('-d', '--daddr', help='Destination address for SIMG',
                            default=None, type=lambda x : int(x, 16))
    fwupdate.add_argument('--skip-crc32', help='Skip crc32 calculation for SIMG',
                            default=False, action='store_true')
    fwupdate.set_defaults(func=fwupdate_command)

    #ecc command
    ecc = subparsers.add_parser('ecc', help='enable or disable ECC')
    ecc_subs = ecc.add_subparsers()

    ecc_on = ecc_subs.add_parser('on', help='enable ECC')
    ecc_on.set_defaults(ecc_mode='on')

    ecc_off = ecc_subs.add_parser('off', help='disable ECC')
    ecc_off.set_defaults(ecc_mode='off')

    ecc.set_defaults(func=ecc_command)

    #sensor command
    sensor = subparsers.add_parser('sensor', help='read sensor value')
    sensor.add_argument('sensor_name', help='Sensor name to read')
    sensor.set_defaults(func=sensor_command)

    #ipinfo command
    ipinfo = subparsers.add_parser('ipinfo', help='get IP info')
    ipinfo.set_defaults(func=ipinfo_command)

    #ipmitool command
    ipmitool = subparsers.add_parser('ipmitool',
            help='run an arbitrary ipmitool command')
    ipmitool.add_argument('ipmitool_args', nargs="+",
            help="ipmitool arguments")
    ipmitool.set_defaults(func=ipmitool_command)

    parser.add_argument('hostname', help='hostname to target')

    return parser

def validate_args(args):
    """ Bail out if the arguments don't make sense"""
    if args.func == fwupdate_command:
        if args.image_type == "SPIF" and args.skip_simg:
            sys.exit('Invalid argument --skip_simg with SPIF image type')
        if args.image_type == "SPIF" and args.force_simg:
            sys.exit('Invalid argument --force_simg with SPIF image type')
        if args.skip_simg and args.version:
            sys.exit('Invalid argument --version when supplied with --skip-simg')
        if args.skip_simg and args.daddr:
            sys.exit('Invalid argument --daddr when supplied with --skip-simg')
        if args.skip_simg and args.skip_crc32:
            sys.exit('Invalid argument --skip-crc32 when supplied with --skip-simg')

def main():
    """Get args and go"""

    parser = build_parser()
    args = parser.parse_args()

    validate_args(args)

    if args.verbose:
        verbosity = 2
    else:
        verbosity = 1
    controller = Controller(verbosity)

    if args.tftp:
        tftp_args = args.tftp.split(':')
        if len(tftp_args) == 1:
            tftp_address = tftp_args[0]
            tftp_port = 69
        elif len(tftp_args) == 2:
            tftp_address = tftp_args[0]
            tftp_port = int(tftp_args[1])
        else:
            print "ERROR: %s is not a valid argument for --tftp" % args.tftp
            return 1
        controller.set_external_tftp_server(tftp_address, tftp_port)
    elif args.internal_tftp:
        tftp_args = args.internal_tftp.split(':')
        if len(tftp_args) == 1:
            tftp_address = tftp_args[0]
            tftp_port = 0
        elif len(tftp_args) == 2:
            tftp_address = tftp_args[0]
            tftp_port = int(tftp_args[1])
        else:
            print ("ERROR: %s is not a valid argument for --internal-tftp"
                    % args.tftp)
            return 1
        controller.set_internal_tftp_server(tftp_address, tftp_port)
    else:
        controller.set_internal_tftp_server()

    try:
        get_addresses(controller, args)
    except ValueError:
        print 'ERROR: Failed to get IP addresses'
        return 1

    sys.exit(args.func(controller, args))

def power_command(controller, args):
    """change the power state of a cluster or host"""
    if args.power_mode == 'policy':
        controller.power_policy(args.policy)
    elif args.power_mode == 'status':
        controller.power_status()
    else:
        controller.power(args.power_mode)

    return 0

def mcreset_command(controller, args):
    """reset the management controllers of a cluster or host"""
    controller.mc_reset()

    return 0

def fwupdate_command(controller, args):
    """update firmware on a cluster or host"""
    if not os.path.exists(args.filename):
        print 'ERROR: File %s does not exist' % args.filename
        return 1

    simg = None
    if args.force_simg:
        simg = False
    elif args.skip_simg:
        simg = True

    # Add image and execute command
    controller.add_image(args.filename, args.image_type,
            simg, args.version, args.daddr, args.skip_crc32)
    controller.update_firmware(args.slot, args.no_reset)

    return 0

def ecc_command(controller, args):
    """enable or disable ECC on a cluster or host"""
    controller.set_ecc(args.ecc_mode)

    return 0

def sensor_command(controller, args):
    """read sensor values from a cluster or host"""
    controller.get_sensor(args.sensor_name)

    return 0

def ipinfo_command(controller, args):
    """get ip info from a cluster or host"""
    controller.get_ipinfo()

    return 0

def ipmitool_command(controller, args):
    """run arbitrary ipmitool command"""
    controller.ipmitool_command(args.ipmitool_args)

    return 0

def get_addresses(controller, args):
    """get initial addresses"""
    addresses = set()
    for entry in args.hostname.split(','):
        try:
            # Treat the entry as an IP range
            start, end = entry.split('-')
            addresses.update(controller.get_targets_in_range(start, end))
        except ValueError:
            # Not an IP range, just add the address directly
            addresses.add(entry)

    if args.all_nodes:
        # Get targets from fabric
        fabric_addresses = set()
        for address in addresses:
            if not address in fabric_addresses:
                new_addresses = controller.get_targets_from_fabric(address,
                        args.user, args.password)
                fabric_addresses.update(new_addresses)
        addresses = addresses.union(fabric_addresses)

    # Add addresses to target group
    for address in addresses:
        controller.add_target(address, args.user, args.password)

if __name__ == '__main__':
    main()
