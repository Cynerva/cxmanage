#!/usr/bin/env python

# Copyright (c) 2012, Calxeda Inc.
#
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
# * Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
# * Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
# * Neither the name of Calxeda Inc. nor the names of its contributors
# may be used to endorse or promote products derived from this software
# without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
# TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
# THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
# DAMAGE.

"""Command line tool for managing a Calxeda cluster"""

# TODO: factor this out into multiple files. We could afford to have a few
# less lines in here. Just a few.

import argparse
import os
import sys
import subprocess
import pkg_resources
import time

from cxmanage_api.tftp import InternalTftp, ExternalTftp
from cxmanage_api.node import Node
from cxmanage_api.tasks import TaskQueue
from cxmanage_api.image import Image
from cxmanage_api.firmware_package import FirmwarePackage
from cxmanage_api.ubootenv import UbootEnv

PYIPMI_VERSION = '0.6.1'
IPMITOOL_VERSION = '1.8.11.0-cx3'

def build_parser():
    """setup the argparse parser"""
    parser = argparse.ArgumentParser(
            description='Calxeda Server Management Utility')

    #global arguments
    parser.add_argument('-V', '--version', action='store_true',
            help='Show version information')
    parser.add_argument('-u', '--user', default='admin',
            help='Username for login')
    parser.add_argument('-p', '--password', default='admin',
            help='Password for login')
    parser.add_argument('-a', '--all-nodes', action='store_true',
            help='Send command to all nodes reported by fabric')
    parser.add_argument('--threads', type=int, default=4,
            metavar='THREAD_COUNT', help='Number of threads to use')
    parser.add_argument('--command_delay', type=float,
            metavar='SECONDS', default=0.0,
            help='Per thread time to delay between issuing commands')
    parser.add_argument('--force', action='store_true',
            help='Force the command to run')
    parser.add_argument('--retry', help='Retry command on multiple times',
            type=int, default=None, metavar='COUNT')
    parser.add_argument('--ipmipath', help='Path to ipmitool command',
            default=None)
    parser.add_argument('-n', '--nodes', metavar='COUNT', type=int,
            help='Expected number of nodes')
    verbosity = parser.add_mutually_exclusive_group()
    verbosity.add_argument('-v', '--verbose', action='store_true',
            help='Verbose output')
    verbosity.add_argument('-q', '--quiet', action='store_true',
            help='Quiet output')
    tftp_type = parser.add_mutually_exclusive_group()
    tftp_type.add_argument('--internal-tftp', metavar='IP:PORT',
            help='Host an internal TFTP server listening on ip:port')
    tftp_type.add_argument('--external-tftp', metavar='IP:PORT',
            help='Connect to remote TFTP server at ip:port')

    subparsers = parser.add_subparsers()

    #power command
    power = subparsers.add_parser('power',
        help='control a9 power')
    power_subs = power.add_subparsers()

    power_on = power_subs.add_parser('on', help='boot the a9')
    power_on.set_defaults(power_mode='on', func=power_command)

    power_off = power_subs.add_parser('off', help='shut the a9 off')
    power_off.set_defaults(power_mode='off', func=power_command)

    power_reset = power_subs.add_parser('reset', help='reset the a9')
    power_reset.set_defaults(power_mode='reset', func=power_command)

    power_status = power_subs.add_parser('status',
            help='get a9 power status')
    power_status.set_defaults(func=power_status_command)

    power_policy = power_subs.add_parser('policy',
            help='set a9 power policy')
    power_policy_subs = power_policy.add_subparsers()

    power_policy_always_on = power_policy_subs.add_parser(
            'always-on', help='always boot the a9 by default')
    power_policy_always_on.set_defaults(policy='always-on',
            func=power_policy_command)
    power_policy_always_off = power_policy_subs.add_parser(
            'always-off', help='never boot the a9 by default')
    power_policy_always_off.set_defaults(policy='always-off',
            func=power_policy_command)
    power_policy_previous = power_policy_subs.add_parser(
            'previous', help='return to previous power state by default')
    power_policy_previous.set_defaults(policy='previous',
            func=power_policy_command)
    power_policy_status = power_policy_subs.add_parser(
            'status', help='get the current power policy')
    power_policy_status.set_defaults(func=power_policy_status_command)

    #mcreset command
    mcreset = subparsers.add_parser('mcreset',
            help='reset the management controller')
    mcreset.set_defaults(func=mcreset_command)

    #fwupdate command
    fwupdate = subparsers.add_parser(
                'fwupdate', help='update firmware')

    fwupdate.add_argument('image_type', metavar='IMAGE_TYPE',
            help='type of image to update', type=lambda string: string.upper(),
            choices = list(sorted([
                'DEL',
                'DEL1',
                'S2_ELF',
                'SOC_ELF',
                'A9_UEFI',
                'A9_UBOOT',
                'A9_EXEC',
                'A9_ELF',
                'SOCDATA',
                'DTB',
                'CDB',
                'UBOOTENV',
                'SEL',
                'BOOT_LOG',
                'UEFI_ENV',
                'DIAG_ELF',
                'PACKAGE'
            ])))
    fwupdate.add_argument('filename', help='path to file to upload')
    fwupdate.add_argument('--partition',
            help='Specify partition to update', default='INACTIVE',
            type=lambda string: string.upper(),
            choices = list([
                'FIRST',
                'SECOND',
                'BOTH',
                'OLDEST',
                'NEWEST',
                'INACTIVE'
            ]))
    simg_args = fwupdate.add_mutually_exclusive_group()
    simg_args.add_argument('--force-simg',
            help='Force addition of SIMG header',
            default=False, action='store_true')
    simg_args.add_argument('--skip-simg',
            help='Skip addition of SIMG header',
            default=False, action='store_true')
    fwupdate.add_argument('--priority',
            help='Priority for SIMG header', default=None, type=int)
    fwupdate.add_argument('-d', '--daddr',
            help='Destination address for SIMG',
            default=None, type=lambda x : int(x, 16))
    fwupdate.add_argument('--skip-crc32',
            help='Skip crc32 calculation for SIMG',
            default=False, action='store_true')
    fwupdate.add_argument('--version', dest='fw_version',
            help='Version for SIMG header', default=None)
    fwupdate.set_defaults(func=fwupdate_command)

    #fwinfo command
    fwinfo = subparsers.add_parser('fwinfo', help='get FW info')
    fwinfo.set_defaults(func=fwinfo_command)

    #sensor command
    sensor = subparsers.add_parser('sensor',
            help='read sensor value')
    sensor.add_argument('sensor_name', help='Sensor name to read',
            nargs='?', default='')
    sensor.set_defaults(func=sensor_command)

    #ipinfo command
    ipinfo = subparsers.add_parser('ipinfo', help='get IP info')
    ipinfo.set_defaults(func=ipinfo_command)

    #macaddrs command
    macaddrs = subparsers.add_parser('macaddrs',
            help='get mac addresses')
    macaddrs.set_defaults(func=macaddrs_command)

    #config command
    config = subparsers.add_parser('config', help='configure hosts')
    config_subs = config.add_subparsers()

    reset = config_subs.add_parser('reset',
            help='reset to factory default')
    reset.set_defaults(func=config_reset_command)

    boot = config_subs.add_parser('boot',
            help='set A9 boot order')
    boot.add_argument('boot_order', help='boot order to use', default=[],
            type=lambda x: [] if x == 'none' else x.split(','))
    boot.set_defaults(func=config_boot_command)

    #info command
    info = subparsers.add_parser('info', help='get host info')
    info.add_argument('info_type', metavar='INFO_TYPE', nargs='?',
            help='info type to get', type=lambda string: string.lower(),
            choices=list(sorted([
                'basic',
                'ubootenv',
                'dump'
            ])))
    info.set_defaults(func=info_command)

    #ipmitool command
    ipmitool = subparsers.add_parser('ipmitool',
            help='run an arbitrary ipmitool command')
    ipmitool.add_argument('-l', '--lanplus',
            action='store_true', default=False,
            help='use lanplus')
    ipmitool.add_argument('ipmitool_args', nargs='+',
            help='ipmitool arguments')
    ipmitool.set_defaults(func=ipmitool_command)

    parser.add_argument('hostname', help='hostname to target')

    return parser


def validate_args(args):
    """ Bail out if the arguments don't make sense"""
    if args.threads < 1:
        sys.exit('ERROR: --threads must be at least 1')
    if args.func == fwupdate_command:
        if args.skip_simg and args.priority:
            sys.exit('Invalid argument --priority when supplied with --skip-simg')
        if args.skip_simg and args.daddr:
            sys.exit('Invalid argument --daddr when supplied with --skip-simg')
        if args.skip_simg and args.skip_crc32:
            sys.exit('Invalid argument --skip-crc32 when supplied with --skip-simg')
        if args.skip_simg and args.fw_version:
            sys.exit('Invalid argument --version when supplied with --skip-simg')

def main():
    """Get args and go"""
    # Have to handle the global -V and --version options before we parse the
    # arguments properly, since cxmanage normally requires a command to run.
    for arg in sys.argv[1:]:
        if arg in ['-V', '--version']:
            print_version()
            sys.exit(0)
        elif arg[0] != '-':
            break

    parser = build_parser()
    args = parser.parse_args()
    validate_args(args)

    if args.ipmipath:
        if os.path.isdir(args.ipmipath):
            args.ipmipath = args.ipmipath.rstrip('/') + '/ipmitool'
        os.environ['IPMITOOL_PATH'] = args.ipmipath

    check_versions()

    sys.exit(args.func(args))


def print_version():
    """ Print the current version of cxmanage """
    version = pkg_resources.require('cxmanage')[0].version
    print "cxmanage version %s" % version


def check_versions():
    """Check versions of dependencies"""
    # Check pyipmi version
    try:
        pkg_resources.require('pyipmi>=%s' % PYIPMI_VERSION)
    except pkg_resources.DistributionNotFound:
        print 'ERROR: cxmanage requires pyipmi version %s'\
                % PYIPMI_VERSION
        print 'No existing version was found.'
        sys.exit(1)
    except pkg_resources.VersionConflict:
        version = pkg_resources.require('pyipmi')[0].version
        print 'ERROR: cxmanage requires pyipmi version %s' % PYIPMI_VERSION
        print 'Current pyipmi version is %s' % version
        sys.exit(1)


    # Check ipmitool version
    if 'IPMITOOL_PATH' in os.environ:
        args = [os.environ['IPMITOOL_PATH'], '-V']
    else:
        args = ['ipmitool', '-V']

    try:
        ipmitool_process = subprocess.Popen(args, stdout=subprocess.PIPE)
        ipmitool_version = ipmitool_process.communicate()[0].split()[2]
        if pkg_resources.parse_version(ipmitool_version) < \
                pkg_resources.parse_version(IPMITOOL_VERSION):
            print 'ERROR: cxmanage requires IPMItool %s or later' \
                    % IPMITOOL_VERSION
            print 'Current IPMItool version is %s' % ipmitool_version
            sys.exit(1)
    except OSError:
        print 'ERROR: cxmanage requires IPMItool %s or later' \
                % IPMITOOL_VERSION
        print 'No existing version was found.'
        sys.exit(1)


def get_tftp(args):
    """Get a TFTP server"""
    if args.internal_tftp:
        tftp_args = args.internal_tftp.split(':')
        if len(tftp_args) == 1:
            ip_address = tftp_args[0]
            port = 0
        elif len(tftp_args) == 2:
            ip_address = tftp_args[0]
            port = int(tftp_args[1])
        else:
            print ('ERROR: %s is not a valid argument for --internal-tftp'
                    % args.internal_tftp)
            sys.exit(1)
        return InternalTftp(ip_address=ip_address, port=port,
                verbose=args.verbose)

    elif args.external_tftp:
        tftp_args = args.external_tftp.split(':')
        if len(tftp_args) == 1:
            ip_address = tftp_args[0]
            port = 69
        elif len(tftp_args) == 2:
            ip_address = tftp_args[0]
            port = int(tftp_args[1])
        else:
            print ('ERROR: %s is not a valid argument for --external-tftp'
                    % args.external_tftp)
            sys.exit(1)
        return ExternalTftp(ip_address=ip_address, port=port,
                verbose=args.verbose)

    return InternalTftp()


def get_nodes(args, tftp, verify_prompt=False):
    """Get nodes"""
    hosts = []
    for entry in args.hostname.split(','):
        hosts.extend(parse_host_entry(entry))

    nodes = [Node(ip_address=x, username=args.user, password=args.password,
            tftp=tftp, verbose=args.verbose) for x in hosts]

    if args.all_nodes:
        if not args.quiet:
            print "Getting IP addresses..."

        results, errors = _run_command(args, nodes, "get_fabric_ipinfo")

        all_nodes = []
        for node in nodes:
            if node in results:
                for ip_address in results[node].itervalues():
                    new_node = Node(ip_address=ip_address, username=args.user,
                            password=args.password, tftp=tftp,
                            verbose=args.verbose)
                    if not new_node in all_nodes:
                        all_nodes.append(new_node)

        if not args.quiet and all_nodes:
            print "Discovered the following IP addresses:"
            for node in all_nodes:
                print node.ip_address
            print

        if errors:
            print "ERROR: Failed to get IP addresses. Aborting.\n"
            sys.exit(1)

        if args.nodes:
            if len(all_nodes) != args.nodes:
                print ("ERROR: Discovered %i nodes, expected %i. Aborting.\n"
                        % (len(all_nodes), args.nodes))
                sys.exit(1)
        elif verify_prompt and not args.force:
            if not prompt_yes("Discovered %i nodes. Continue?"
                    % len(all_nodes)):
                sys.exit(1)

        return all_nodes

    return nodes


def parse_host_entry(entry, hostfiles=set()):
    """parse a host entry"""
    try:
        return parse_hostfile_entry(entry, hostfiles)
    except ValueError:
        try:
            return parse_ip_range_entry(entry)
        except ValueError:
            return [entry]


def parse_hostfile_entry(entry, hostfiles=set()):
    """parse a hostfile entry, returning a list of hosts"""
    if entry.startswith('file='):
        filename = entry[5:]
    elif entry.startswith('hostfile='):
        filename = entry[9:]
    else:
        raise ValueError('%s is not a hostfile entry' % entry)

    if filename in hostfiles:
        return []
    hostfiles.add(filename)

    entries = []
    try:
        for line in open(filename):
            for element in line.partition('#')[0].split():
                for hostfile_entry in element.split(','):
                    entries.extend(parse_host_entry(hostfile_entry, hostfiles))
    except IOError:
        print 'ERROR: %s is not a valid hostfile entry' % entry
        sys.exit(1)

    return entries


def parse_ip_range_entry(entry):
    """ Get a list of ip addresses in a given range"""
    try:
        start, end = entry.split('-')

        # Convert start address to int
        start_bytes = map(int, start.split('.'))
        start_i = ((start_bytes[0] << 24) | (start_bytes[1] << 16)
                | (start_bytes[2] << 8) | (start_bytes[3]))

        # Convert end address to int
        end_bytes = map(int, end.split('.'))
        end_i = ((end_bytes[0] << 24) | (end_bytes[1] << 16)
                | (end_bytes[2] << 8) | (end_bytes[3]))

        # Get ip addresses in range
        addresses = []
        for i in range(start_i, end_i + 1):
            address_bytes = [(i >> (24 - 8 * x)) & 0xff for x in range(4)]
            addresses.append('%i.%i.%i.%i' % tuple(address_bytes))

    except (ValueError, IndexError):
        raise ValueError('%s is not an IP range' % entry)

    return addresses


def prompt_yes(prompt):
    sys.stdout.write("%s (y/n) " % prompt)
    sys.stdout.flush()
    while True:
        command = raw_input().strip().lower()
        if command in ['y', 'yes']:
            print
            return True
        elif command in ['n', 'no']:
            print
            return False


def power_command(args):
    """change the power state of a cluster or host"""
    tftp = get_tftp(args)
    nodes = get_nodes(args, tftp)

    if not args.quiet:
        print 'Sending power %s command...' % args.power_mode

    results, errors = _run_command(args, nodes, 'set_power', args.power_mode)

    if not args.quiet and not errors:
        print 'Command completed successfully.\n'

    return len(errors) > 0


def power_status_command(args):
    tftp = get_tftp(args)
    nodes = get_nodes(args, tftp)

    if not args.quiet:
        print 'Getting power status...'
    results, errors = _run_command(args, nodes, 'get_power')

    # Print results
    if results:
        print 'Power status'
        for node in nodes:
            if node in results:
                if results[node]:
                    result = 'on'
                else:
                    result = 'off'
                print '%s: %s' % (node.ip_address.ljust(16), result)
        print

    if not args.quiet and errors:
        print 'Some errors occured during the command.\n'

    return len(errors) > 0


def power_policy_command(args):
    tftp = get_tftp(args)
    nodes = get_nodes(args, tftp)

    if not args.quiet:
        print 'Setting power policy to %s...' % args.policy

    results, errors = _run_command(args, nodes, 'set_power_policy',
            args.policy)

    if not args.quiet and not errors:
        print 'Command completed successfully.\n'

    return len(errors) > 0


def power_policy_status_command(args):
    tftp = get_tftp(args)
    nodes = get_nodes(args, tftp)

    if not args.quiet:
        print 'Getting power policy status...'
    results, errors = _run_command(args, nodes, 'get_power_policy')

    # Print results
    if results:
        print 'Power policy status'
        for node in nodes:
            if node in results:
                print '%s: %s' % (node.ip_address.ljust(16), results[node])
        print

    if not args.quiet and errors:
        print 'Some errors occured during the command.\n'

    return len(errors) > 0


def mcreset_command(args):
    """reset the management controllers of a cluster or host"""
    tftp = get_tftp(args)
    nodes = get_nodes(args, tftp)

    if not args.quiet:
        print 'Sending MC reset command...'

    results, errors = _run_command(args, nodes, 'mc_reset')

    if not args.quiet and not errors:
        print 'Command completed successfully.\n'

    return len(errors) > 0


def fwupdate_command(args):
    """update firmware on a cluster or host"""
    # Get firmware package
    if args.image_type == "PACKAGE":
        package = FirmwarePackage(args.filename)
    else:
        try:
            simg = None
            if args.force_simg:
                simg = False
            elif args.skip_simg:
                simg = True

            image = Image(args.filename, args.image_type, simg, args.daddr,
                    args.skip_crc32, args.fw_version)
            package = FirmwarePackage()
            package.images.append(image)
        except ValueError as e:
            print "ERROR: %s" % e
            return True

    # Print all_nodes warning/confirmation
    if not args.all_nodes:
        if args.force:
            print 'WARNING: Updating firmware without --all-nodes is dangerous.'
        else:
            if not prompt_yes(
                    'WARNING: Updating firmware without --all-nodes is dangerous. Continue?'):
                return 1


    tftp = get_tftp(args)
    nodes = get_nodes(args, tftp, verify_prompt=True)

    if not args.force:
        if not args.quiet:
            print "Checking hosts..."

        results, errors = _run_command(args, nodes, "_check_firmware", package,
                args.partition, args.priority)
        if errors:
            print "ERROR: Firmware update aborted."
            return True

    if not args.quiet:
        print "Updating firmware..."

    results, errors = _run_command(args, nodes, "update_firmware", package,
            args.partition, args.priority)

    if not args.quiet and not errors:
        print "Command completed successfully.\n"

    return len(errors) > 0


def fwinfo_command(args):
    """print firmware info"""
    tftp = get_tftp(args)
    nodes = get_nodes(args, tftp)

    if not args.quiet:
        print "Getting firmware info..."

    results, errors = _run_command(args, nodes, "get_firmware_info")

    for node in nodes:
        if node in results:
            print "[ Firmware info for %s ]" % node.ip_address

            for partition in results[node]:
                print "Partition : %s" % partition.partition
                print "Type      : %s" % partition.type
                print "Offset    : %s" % partition.offset
                print "Size      : %s" % partition.size
                print "Priority  : %s" % partition.priority
                print "Daddr     : %s" % partition.daddr
                print "Flags     : %s" % partition.flags
                print "Version   : %s" % partition.version
                print "In Use    : %s" % partition.in_use
                print

    if not args.quiet and errors:
        print "Some errors occured during the command.\n"

    return len(errors) > 0


def sensor_command(args):
    """read sensor values from a cluster or host"""
    tftp = get_tftp(args)
    nodes = get_nodes(args, tftp)

    if not args.quiet:
        print "Getting sensor readings..."
    results, errors = _run_command(args, nodes, "get_sensors",
            args.sensor_name)

    sensors = {}
    for node in results:
        for sensor_name, sensor in results[node].iteritems():
            if not sensor_name in sensors:
                sensors[sensor_name] = []

            reading = sensor.sensor_reading.replace("(+/- 0) ", "")
            try:
                value = float(reading.split()[0])
                suffix = reading.lstrip("%f " % value)
                sensors[sensor_name].append((node, value, suffix))
            except ValueError:
                sensors[sensor_name].append((node, reading, ""))

    for sensor_name, readings in sensors.iteritems():
        print sensor_name

        for node, reading, suffix in readings:
            print "%s: %.2f %s" % (node.ip_address.ljust(16), reading, suffix)

        try:
            if all(suffix == x[2] for x in readings):
                minimum = min(x[1] for x in readings)
                maximum = max(x[1] for x in readings)
                average = sum(x[1] for x in readings) / len(readings)
                print "Minimum         : %.2f %s" % (minimum, suffix)
                print "Maximum         : %.2f %s" % (maximum, suffix)
                print "Average         : %.2f %s" % (average, suffix)
        except ValueError:
            pass

        print

    if not args.quiet and errors:
        print "Some errors occured during the command.\n"

    return len(errors) > 0


def ipinfo_command(args):
    """get ip info from a cluster or host"""
    args.all_nodes = False

    tftp = get_tftp(args)
    nodes = get_nodes(args, tftp)

    if not args.quiet:
        print "Getting IP addresses..."

    results, errors = _run_command(args, nodes, "get_fabric_ipinfo")

    for node in nodes:
        if node in results:
            print 'IP info from %s' % node.ip_address
            for node_id, node_address in results[node].iteritems():
                print 'Node %i: %s' % (node_id, node_address)
            print

    return 0


def macaddrs_command(args):
    """get mac addresses from a cluster or host"""
    args.all_nodes = False

    tftp = get_tftp(args)
    nodes = get_nodes(args, tftp)

    if not args.quiet:
        print "Getting MAC addresses..."
    results, errors = _run_command(args, nodes, "get_fabric_macaddrs")

    for node in nodes:
        if node in results:
            print "MAC addresses from %s" % node.ip_address
            for node_id in results[node]:
                for port in results[node][node_id]:
                    mac_address = results[node][node_id][port]
                    print "Node %i, Port %i: %s" % (node_id, port, mac_address)
            print

    if not args.quiet and errors:
        print "Some errors occured during the command.\n"

    return len(errors) == 0


def config_reset_command(args):
    """reset to factory default settings"""
    tftp = get_tftp(args)
    nodes = get_nodes(args, tftp, verify_prompt=True)

    if not args.quiet:
        print "Sending config reset command..."

    results, errors = _run_command(args, nodes, "config_reset")

    if not args.quiet and not errors:
        print "Command completed successfully.\n"

    return len(errors) > 0


def config_boot_command(args):
    """set A9 boot order"""
    if args.boot_order == ['status']:
        return config_boot_status_command(args)

    # Make sure boot_args are valid
    try:
        UbootEnv().set_boot_order(args.boot_order)
    except ValueError as e:
        print e
        return True

    tftp = get_tftp(args)
    nodes = get_nodes(args, tftp)

    if not args.quiet:
        print "Setting boot order..."

    results, errors = _run_command(args, nodes, "set_boot_order",
            args.boot_order)

    if not args.quiet and not errors:
        print "Command completed successfully.\n"

    return len(errors) > 0


def config_boot_status_command(args):
    tftp = get_tftp(args)
    nodes = get_nodes(args, tftp)

    if not args.quiet:
        print "Getting boot order..."
    results, errors = _run_command(args, nodes, "get_boot_order")

    # Print results
    if results:
        print "Boot order"
        for node in nodes:
            if node in results:
                print "%s: %s" % (node.ip_address.ljust(16),
                        ",".join(results[node]))
        print

    if not args.quiet and errors:
        print "Some errors occured during the command.\n"

    return len(errors) > 0


def info_command(args):
    """print info from a cluster or host"""
    if args.info_type in [None, 'basic']:
        return info_basic_command(args)
    elif args.info_type == 'ubootenv':
        return info_ubootenv_command(args)
    elif args.info_type == 'dump':
        return info_dump_command(args)


def info_basic_command(args):
    """Print basic info"""
    components = [
        ("ecme_version", "ECME version"),
        ("cdb_version", "CDB version"),
        ("stage2_version", "Stage2boot version"),
        ("bootlog_version", "Bootlog version"),
        ("a9boot_version", "A9boot version"),
        ("uboot_version", "Uboot version"),
        ("ubootenv_version", "Ubootenv version"),
        ("dtb_version", "DTB version")
    ]

    tftp = get_tftp(args)
    nodes = get_nodes(args, tftp)

    if not args.quiet:
        print "Getting info..."
    results, errors = _run_command(args, nodes, "get_versions")

    # Print results
    for node in nodes:
        if node in results:
            result = results[node]
            print "[ Info from %s ]" % node.ip_address
            print "Hardware version   : %s" % result.hardware_version
            print "Firmware version   : %s" % result.firmware_version
            for var, string in components:
                if hasattr(result, var):
                    version = getattr(result, var)
                    print "%s: %s" % (string.ljust(19), version)
            print

    if not args.quiet and errors:
        print "Some errors occured during the command.\n"

    return len(errors) > 0


def info_ubootenv_command(args):
    tftp = get_tftp(args)
    nodes = get_nodes(args, tftp)

    if not args.quiet:
        print "Getting u-boot environment..."
    results, errors = _run_command(args, nodes, "get_ubootenv")

    # Print results
    for node in nodes:
        if node in results:
            ubootenv = results[node]
            print "[ U-Boot Environment from %s ]" % node.ip_address
            for variable in ubootenv.variables:
                print "%s=%s" % (variable, ubootenv.variables[variable])
            print

    if not args.quiet and errors:
        print "Some errors occured during the command.\n"

    return len(errors) > 0


def info_dump_command(args):
    tftp = get_tftp(args)
    nodes = get_nodes(args, tftp)

    if not args.quiet:
        print "Getting info dump..."
    results, errors = _run_command(args, nodes, "info_dump")

    # Print results
    for node in nodes:
        if node in results:
            print "[ Info dump from %s ]" % node.ip_address
            print results[node]
            print

    if not args.quiet and errors:
        print "Some errors occured during the command.\n"

    return len(errors) > 0


def ipmitool_command(args):
    """run arbitrary ipmitool command"""
    if args.lanplus:
        ipmitool_args = ['-I', 'lanplus'] + args.ipmitool_args
    else:
        ipmitool_args = args.ipmitool_args

    tftp = get_tftp(args)
    nodes = get_nodes(args, tftp)

    if not args.quiet:
        print "Running IPMItool command..."
    results, errors = _run_command(args, nodes, "ipmitool_command",
            ipmitool_args)

    # Print results
    for node in nodes:
        if node in results and results[node] != "":
            print "[ IPMItool output from %s ]" % node.ip_address
            print results[node]
            print

    if not args.quiet and errors:
        print "Some errors occured during the command.\n"

    return len(errors) > 0


def _run_command(args, nodes, name, *method_args):
    task_queue = TaskQueue(threads=args.threads, delay=args.command_delay)
    tasks = {}
    for node in nodes:
        tasks[node] = task_queue.put(getattr(node, name), *method_args)

    results = {}
    errors = {}
    try:
        counter = 0
        while any(x.is_alive() for x in tasks.values()):
            if not args.quiet:
                _print_command_status(tasks, counter)
                counter += 1
            time.sleep(0.25)

        for node, task in tasks.iteritems():
            if task.status == "Completed":
                results[node] = task.result
            else:
                errors[node] = task.error

    except KeyboardInterrupt:
        args.retry = 0

        for node, task in tasks.iteritems():
            if task.status == "Completed":
                results[node] = task.result
            elif task.status == "Failed":
                errors[node] = task.error
            else:
                errors[node] = KeyboardInterrupt("Aborted by keyboard interrupt")

    if not args.quiet:
        _print_command_status(tasks, counter)
        print "\n"

    # Handle errors
    should_retry = False
    if errors:
        _print_errors(nodes, errors)
        if args.retry == None:
            sys.stdout.write("Retry command on failed hosts? (y/n): ")
            sys.stdout.flush()
            while True:
                command = raw_input().strip().lower()
                if command in ['y', 'yes']:
                    should_retry = True
                    break
                elif command in ['n', 'no']:
                    print
                    break
        elif args.retry >= 1:
            should_retry = True
            if args.retry == 1:
                print "Retrying command 1 more time..."
            elif args.retry > 1:
                print "Retrying command %i more times..." % args.retry
            args.retry -= 1

    if should_retry:
        nodes = [x for x in nodes if x in errors]
        new_results, errors = _run_command(args, nodes, name, *method_args)
        results.update(new_results)

    return results, errors


def _print_errors(nodes, errors):
    """ Print errors if they occured """
    if errors:
        print "Command failed on these hosts"
        for node in nodes:
            if node in errors:
                print "%s: %s" % (node.ip_address.ljust(16),
                        errors[node])
        print


def _print_command_status(tasks, counter):
    """ Print the status of a command """
    message = "\r%i successes  |  %i errors  |  %i nodes left  |  %s"
    successes = len([x for x in tasks.values() if x.status == "Completed"])
    errors = len([x for x in tasks.values() if x.status == "Failed"])
    nodes_left = len(tasks) - successes - errors
    dots = "".join(["." for x in range(counter % 4)]).ljust(3)
    sys.stdout.write(message % (successes, errors, nodes_left, dots))
    sys.stdout.flush()


if __name__ == '__main__':
    main()
