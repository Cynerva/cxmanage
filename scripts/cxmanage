#!/usr/bin/env python

#Copyright 2012 Calxeda, Inc.  All rights reserved.

"""Command line tool for managing a Calxeda cluster"""

import argparse
import sys

from cxmanage.plugins import add_args
from cxmanage.controller import Controller

def build_parser():
    """setup the argparse parser"""
    p = {}

    p['parser'] = argparse.ArgumentParser(
            description='Calxeda Server Management Utility')

    #global arguments
    p['parser'].add_argument('-u', '--user', default='admin',
            help='Username for login')
    p['parser'].add_argument('-p', '--password', default='admin',
            help='Password for login')
    p['parser'].add_argument('-a', '--all-nodes', action='store_true',
            help='Send command to all nodes reported by fabric')
    p['verbosity'] = p['parser'].add_mutually_exclusive_group()
    p['verbosity'].add_argument('-v', '--verbose', action='store_true',
            help='Verbose output')
    p['verbosity'].add_argument('-q', '--quiet', action='store_true',
            help='Quiet output')
    p['tftp_type'] = p['parser'].add_mutually_exclusive_group()
    p['tftp_type'].add_argument('-t', '--tftp',
            help='Connect to remote TFTP server at <ip:port>')
    p['tftp_type'].add_argument('--internal-tftp',
            help='Host an internal TFTP server listening on <ip:port>')

    p['subparsers'] = p['parser'].add_subparsers()

    #power command
    p['power'] = p['subparsers'].add_parser('power',
        help='control a9 power')
    p['power_subs'] = p['power'].add_subparsers()

    p['power_on'] = p['power_subs'].add_parser('on', help='boot the a9')
    p['power_on'].set_defaults(power_mode='on')

    p['power_off'] = p['power_subs'].add_parser('off', help='shut the a9 off')
    p['power_off'].set_defaults(power_mode='off')

    p['power_reset'] = p['power_subs'].add_parser('reset', help='reset the a9')
    p['power_reset'].set_defaults(power_mode='reset')

    p['power_status'] = p['power_subs'].add_parser('status',
            help='get a9 power status')
    p['power_status'].set_defaults(power_mode='status')

    p['power_policy'] = p['power_subs'].add_parser('policy',
            help='set a9 power policy')
    p['power_policy'].add_argument('policy', help='Policy to set',
            choices=['always-on', 'always-off', 'previous', 'status'])
    p['power_policy'].set_defaults(power_mode='policy')

    p['power'].set_defaults(func=power_command)

    #mcreset command
    p['mcreset'] = p['subparsers'].add_parser('mcreset',
            help='reset the management controller')
    p['mcreset'].set_defaults(func=mcreset_command)

    #fwupdate command
    p['fwupdate'] = p['subparsers'].add_parser(
                'fwupdate', help='update firmware')

    p['fwupdate'].add_argument('image_type', metavar='IMAGE_TYPE',
            help='type of image to update', type=lambda string: string.upper(),
                        choices = list(sorted([
                            'DEL',
                            'DEL1',
                            'S2_ELF',
                            'SOC_ELF',
                            'A9_UEFI',
                            'A9_UBOOT',
                            'A9_EXEC',
                            'A9_ELF',
                            'SOCDATA',
                            'DTB',
                            'CDB',
                            'UBOOTENV',
                            'SEL',
                            'BOOT_LOG',
                            'UEFI_ENV',
                            'DIAG_ELF',
                            'PACKAGE'
                        ])))
    p['fwupdate'].add_argument('filename', help='path to file to upload')
    p['fwupdate'].add_argument('--slot', help='Specify slot to update',
                            default='INACTIVE',
                            type=lambda string: string.upper(),
                            choices = list(sorted([
                                'FIRST',
                                'SECOND',
                                'THIRD',
                                'BOTH',
                                'OLDEST',
                                'NEWEST',
                                'INACTIVE'
                            ]))
            )
    p['simg_args'] = p['fwupdate'].add_mutually_exclusive_group()
    p['simg_args'].add_argument('--force-simg',
            help='Force addition of SIMG header',
            default=False, action='store_true')
    p['simg_args'].add_argument('--skip-simg',
            help='Skip addition of SIMG header',
            default=False, action='store_true')
    p['fwupdate'].add_argument('--version',
            help='Version for SIMG header', default=None, type=int)
    p['fwupdate'].add_argument('-d', '--daddr',
            help='Destination address for SIMG',
            default=None, type=lambda x : int(x, 16))
    p['fwupdate'].add_argument('--skip-crc32',
            help='Skip crc32 calculation for SIMG',
            default=False, action='store_true')
    p['fwupdate'].set_defaults(func=fwupdate_command)

    #sensor command
    p['sensor'] = p['subparsers'].add_parser(
            'sensor', help='read sensor value')
    p['sensor'].add_argument('sensor_name', help='Sensor name to read')
    p['sensor'].set_defaults(func=sensor_command)

    #ipinfo command
    p['ipinfo'] = p['subparsers'].add_parser('ipinfo', help='get IP info')
    p['ipinfo'].set_defaults(func=ipinfo_command)

    #config command
    p['config'] = p['subparsers'].add_parser('config', help='configure hosts')
    p['config_subs'] = p['config'].add_subparsers()

    p['reset'] = p['config_subs'].add_parser('reset',
            help='reset to factory default')
    p['reset'].set_defaults(func=config_reset_command)

    #ipmitool command
    p['ipmitool'] = p['subparsers'].add_parser('ipmitool',
            help='run an arbitrary ipmitool command')
    p['ipmitool'].add_argument('ipmitool_args', nargs="+",
            help="ipmitool arguments")
    p['ipmitool'].set_defaults(func=ipmitool_command)

    p['parser'].add_argument('hostname', help='hostname to target')

    add_args(p)

    return p['parser']


def validate_args(args):
    """ Bail out if the arguments don't make sense"""
    if args.func == fwupdate_command:
        if args.skip_simg and args.version:
            sys.exit('Invalid argument --version when supplied with --skip-simg')
        if args.skip_simg and args.daddr:
            sys.exit('Invalid argument --daddr when supplied with --skip-simg')
        if args.skip_simg and args.skip_crc32:
            sys.exit('Invalid argument --skip-crc32 when supplied with --skip-simg')


def main():
    """Get args and go"""

    parser = build_parser()
    args = parser.parse_args()

    validate_args(args)

    verbosity = 1
    if args.verbose:
        verbosity = 2
    elif args.quiet:
        verbosity = 0
    controller = Controller(verbosity)

    if args.tftp:
        tftp_args = args.tftp.split(':')
        if len(tftp_args) == 1:
            tftp_address = tftp_args[0]
            tftp_port = 69
        elif len(tftp_args) == 2:
            tftp_address = tftp_args[0]
            tftp_port = int(tftp_args[1])
        else:
            print "ERROR: %s is not a valid argument for --tftp" % args.tftp
            sys.exit(1)
        controller.set_external_tftp_server(tftp_address, tftp_port)
    elif args.internal_tftp:
        tftp_args = args.internal_tftp.split(':')
        if len(tftp_args) == 1:
            tftp_address = tftp_args[0]
            tftp_port = 0
        elif len(tftp_args) == 2:
            tftp_address = tftp_args[0]
            tftp_port = int(tftp_args[1])
        else:
            print ("ERROR: %s is not a valid argument for --internal-tftp"
                    % args.tftp)
            sys.exit(1)
        controller.set_internal_tftp_server(tftp_address, tftp_port)
    else:
        controller.set_internal_tftp_server()

    try:
        get_addresses(controller, args)
    except ValueError:
        print 'ERROR: Failed to get IP addresses'
        sys.exit(1)

    sys.exit(args.func(controller, args))


def power_command(controller, args):
    """change the power state of a cluster or host"""

    # power policy
    if args.power_mode == 'policy':
        if args.policy == 'status':
            if controller.power_policy_status():
                return 1
        elif controller.power_policy(args.policy):
            return 1

    # power status
    elif args.power_mode == 'status':
        if controller.power_status():
            return 1

    # power on/off/reset
    else:
        if controller.power(args.power_mode):
            return 1

    return 0


def mcreset_command(controller, args):
    """reset the management controllers of a cluster or host"""
    if controller.mc_reset():
        return 1
    return 0


def fwupdate_command(controller, args):
    """update firmware on a cluster or host"""
    simg = None
    if args.force_simg:
        simg = False
    elif args.skip_simg:
        simg = True

    # Add image
    controller.add_image(args.filename, args.image_type,
            simg, args.version, args.daddr, args.skip_crc32)

    # Do firmware update
    if controller.update_firmware(args.slot, True):
        return 1
    return 0


def sensor_command(controller, args):
    """read sensor values from a cluster or host"""
    if controller.get_sensor(args.sensor_name):
        return 1
    return 0


def ipinfo_command(controller, args):
    """get ip info from a cluster or host"""
    if controller.get_ipinfo():
        return 1
    return 0


def config_reset_command(controller, args):
    if controller.config_reset():
        return 1
    return 0


def ipmitool_command(controller, args):
    """run arbitrary ipmitool command"""
    if controller.ipmitool_command(args.ipmitool_args):
        return 1
    return 0


def get_addresses(controller, args):
    """get initial addresses"""
    addresses = set()
    for entry in args.hostname.split(','):
        try:
            # Treat the entry as an IP range
            start, end = entry.split('-')
            addresses.update(controller.get_targets_in_range(start, end))
        except ValueError:
            # Not an IP range, just add the address directly
            addresses.add(entry)

    if args.all_nodes:
        # Get targets from fabric
        fabric_addresses = set()
        for address in addresses:
            if not address in fabric_addresses:
                new_addresses = controller.get_targets_from_fabric(address,
                        args.user, args.password)
                fabric_addresses.update(new_addresses)
        addresses = addresses.union(fabric_addresses)

    # Add addresses to target group
    for address in addresses:
        controller.add_target(address, args.user, args.password)


if __name__ == '__main__':
    main()
