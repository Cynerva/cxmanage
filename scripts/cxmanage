#!/usr/bin/env python

# Copyright (c) 2012, Calxeda Inc.
#
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
# * Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
# * Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
# * Neither the name of Calxeda Inc. nor the names of its contributors
# may be used to endorse or promote products derived from this software
# without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
# TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
# THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
# DAMAGE.


"""Command line tool for managing a Calxeda cluster"""

import argparse
import os
import pkgutil
import sys
import subprocess

from cxmanage.controller import Controller

# Load plugins
PREFIX = 'cxmanage_plugin'
PLUGINS = [__import__(x[1]) for x in pkgutil.iter_modules()
        if x[1].startswith(PREFIX)]

def build_parser():
    """setup the argparse parser"""
    p = {}

    p['parser'] = argparse.ArgumentParser(
            description='Calxeda Server Management Utility')

    #global arguments
    p['parser'].add_argument('-u', '--user', default='admin',
            help='Username for login')
    p['parser'].add_argument('-p', '--password', default='admin',
            help='Password for login')
    p['parser'].add_argument('-a', '--all-nodes', action='store_true',
            help='Send command to all nodes reported by fabric')
    p['parser'].add_argument('--threads', type=int, default=4,
            metavar='THREAD_COUNT', help='Number of threads to use')
    p['parser'].add_argument('--force-yes', action='store_true',
            help='Don\'t stop at confirmation dialogue')
    p['parser'].add_argument('--retry', help='Retry command on multiple times',
            type=int, default=None, metavar='COUNT')
    p['parser'].add_argument('--ipmipath', help='Path to ipmitool command',
            default=None)
    p['verbosity'] = p['parser'].add_mutually_exclusive_group()
    p['verbosity'].add_argument('-v', '--verbose', action='store_true',
            help='Verbose output')
    p['verbosity'].add_argument('-q', '--quiet', action='store_true',
            help='Quiet output')
    p['tftp_type'] = p['parser'].add_mutually_exclusive_group()
    p['tftp_type'].add_argument('--internal-tftp', metavar='IP:PORT',
            help='Host an internal TFTP server listening on ip:port')
    p['tftp_type'].add_argument('--external-tftp', metavar='IP:PORT',
            help='Connect to remote TFTP server at ip:port')

    p['subparsers'] = p['parser'].add_subparsers()

    #power command
    p['power'] = p['subparsers'].add_parser('power',
        help='control a9 power')
    p['power_subs'] = p['power'].add_subparsers()

    p['power_on'] = p['power_subs'].add_parser('on', help='boot the a9')
    p['power_on'].set_defaults(power_mode='on')

    p['power_off'] = p['power_subs'].add_parser('off', help='shut the a9 off')
    p['power_off'].set_defaults(power_mode='off')

    p['power_reset'] = p['power_subs'].add_parser('reset', help='reset the a9')
    p['power_reset'].set_defaults(power_mode='reset')

    p['power_status'] = p['power_subs'].add_parser('status',
            help='get a9 power status')
    p['power_status'].set_defaults(power_mode='status')

    p['power_policy'] = p['power_subs'].add_parser('policy',
            help='set a9 power policy')
    p['power_policy'].add_argument('policy', help='Policy to set',
            choices=['always-on', 'always-off', 'previous', 'status'])
    p['power_policy'].set_defaults(power_mode='policy')

    p['power'].set_defaults(func=power_command)

    #mcreset command
    p['mcreset'] = p['subparsers'].add_parser('mcreset',
            help='reset the management controller')
    p['mcreset'].set_defaults(func=mcreset_command)

    #fwupdate command
    p['fwupdate'] = p['subparsers'].add_parser(
                'fwupdate', help='update firmware')

    p['fwupdate'].add_argument('image_type', metavar='IMAGE_TYPE',
            help='type of image to update', type=lambda string: string.upper(),
            choices = list(sorted([
                'DEL',
                'DEL1',
                'S2_ELF',
                'SOC_ELF',
                'A9_UEFI',
                'A9_UBOOT',
                'A9_EXEC',
                'A9_ELF',
                'SOCDATA',
                'DTB',
                'CDB',
                'UBOOTENV',
                'SEL',
                'BOOT_LOG',
                'UEFI_ENV',
                'DIAG_ELF',
                'PACKAGE'
            ])))
    p['fwupdate'].add_argument('filename', help='path to file to upload')
    p['fwupdate'].add_argument('--partition',
            help='Specify partition to update', default='INACTIVE',
            type=lambda string: string.upper(),
            choices = list([
                'FIRST',
                'SECOND',
                'BOTH',
                'OLDEST',
                'NEWEST',
                'INACTIVE'
            ]))
    p['simg_args'] = p['fwupdate'].add_mutually_exclusive_group()
    p['simg_args'].add_argument('--force-simg',
            help='Force addition of SIMG header',
            default=False, action='store_true')
    p['simg_args'].add_argument('--skip-simg',
            help='Skip addition of SIMG header',
            default=False, action='store_true')
    p['fwupdate'].add_argument('--version',
            help='Version for SIMG header', default=None, type=int)
    p['fwupdate'].add_argument('-d', '--daddr',
            help='Destination address for SIMG',
            default=None, type=lambda x : int(x, 16))
    p['fwupdate'].add_argument('--skip-crc32',
            help='Skip crc32 calculation for SIMG',
            default=False, action='store_true')
    p['fwupdate'].set_defaults(func=fwupdate_command)

    #fwinfo command
    p['fwinfo'] = p['subparsers'].add_parser('fwinfo', help='get FW info')
    p['fwinfo'].set_defaults(func=fwinfo_command)

    #sensor command
    p['sensor'] = p['subparsers'].add_parser('sensor',
            help='read sensor value')
    p['sensor'].add_argument('sensor_name', help='Sensor name to read',
            nargs='?', default='')
    p['sensor'].set_defaults(func=sensor_command)

    #ipinfo command
    p['ipinfo'] = p['subparsers'].add_parser('ipinfo', help='get IP info')
    p['ipinfo'].set_defaults(func=ipinfo_command)

    #macaddrs command
    p['macaddrs'] = p['subparsers'].add_parser('macaddrs',
            help='get mac addresses')
    p['macaddrs'].set_defaults(func=macaddrs_command)

    #config command
    p['config'] = p['subparsers'].add_parser('config', help='configure hosts')
    p['config_subs'] = p['config'].add_subparsers()

    p['reset'] = p['config_subs'].add_parser('reset',
            help='reset to factory default')
    p['reset'].set_defaults(func=config_reset_command)

    p['boot'] = p['config_subs'].add_parser('boot',
            help='set A9 boot order')
    p['boot'].add_argument('boot_order', help='boot order to use')
    p['boot'].set_defaults(func=config_boot_command)

    #info command
    p['info'] = p['subparsers'].add_parser('info', help='get host info')
    p['info'].add_argument('info_type', metavar='INFO_TYPE', nargs='?',
            help='info type to get', type=lambda string: string.lower(),
            choices=list(sorted([
                'basic',
                'ubootenv',
                'dump'
            ])))
    p['info'].set_defaults(func=info_command)

    #ipmitool command
    p['ipmitool'] = p['subparsers'].add_parser('ipmitool',
            help='run an arbitrary ipmitool command')
    p['ipmitool'].add_argument('-l', '--lanplus',
            action='store_true', default=False,
            help='use lanplus')
    p['ipmitool'].add_argument('ipmitool_args', nargs='+',
            help='ipmitool arguments')
    p['ipmitool'].set_defaults(func=ipmitool_command)

    p['parser'].add_argument('hostname', help='hostname to target')

    #plugin commands
    for plugin in PLUGINS:
        plugin.add_args(p)

    return p['parser']


def validate_args(args):
    """ Bail out if the arguments don't make sense"""
    if args.threads < 1:
        sys.exit('ERROR: --threads must be at least 1')
    if args.func == fwupdate_command:
        if args.skip_simg and args.version:
            sys.exit('Invalid argument --version when supplied with --skip-simg')
        if args.skip_simg and args.daddr:
            sys.exit('Invalid argument --daddr when supplied with --skip-simg')
        if args.skip_simg and args.skip_crc32:
            sys.exit('Invalid argument --skip-crc32 when supplied with --skip-simg')

def main():
    """Get args and go"""
    # Parse arguments
    parser = build_parser()
    args = parser.parse_args()
    validate_args(args)

    # Set ipmitool path
    if args.ipmipath:
        if os.path.isdir(args.ipmipath):
            args.ipmipath = args.ipmipath.rstrip('/') + '/ipmitool'
        print args.ipmipath
        os.environ['IPMITOOL_PATH'] = args.ipmipath

    # Check versions
    check_versions()

    # Make the controller
    verbosity = 1
    if args.verbose:
        verbosity = 2
    elif args.quiet:
        verbosity = 0
    controller = Controller(verbosity=verbosity, max_threads=args.threads,
            retries=args.retry)

    # Set TFTP and add targets
    set_tftp(controller, args)
    add_targets(controller, args)

    # Run the command
    sys.exit(args.func(controller, args))


def check_versions():
    """Check versions of dependencies"""
    # Check ipmitool version
    if 'IPMITOOL_PATH' in os.environ:
        args = [os.environ['IPMITOOL_PATH'], '-V']
    else:
        args = ['ipmitool', '-V']
    ipmitool_version = subprocess.check_output(args).split()[2]
    if not '-cx' in ipmitool_version:
        print ('ERROR: cxmanage is not compatible with IPMItool version %s\n'
                % ipmitool_version)
        print 'Please make sure a Calxeda extended version of IPMItool is available'
        print 'in your PATH, or point to one with the --ipmipath argument.'
        sys.exit(1)


def set_tftp(controller, args):
    """Set up tftp server on controller"""
    if args.internal_tftp:
        tftp_args = args.internal_tftp.split(':')
        if len(tftp_args) == 1:
            tftp_address = tftp_args[0]
            tftp_port = 0
        elif len(tftp_args) == 2:
            tftp_address = tftp_args[0]
            tftp_port = int(tftp_args[1])
        else:
            print ('ERROR: %s is not a valid argument for --internal-tftp'
                    % args.internal_tftp)
            sys.exit(1)
        controller.set_internal_tftp_server(tftp_address, tftp_port)
    elif args.external_tftp:
        tftp_args = args.external_tftp.split(':')
        if len(tftp_args) == 1:
            tftp_address = tftp_args[0]
            tftp_port = 69
        elif len(tftp_args) == 2:
            tftp_address = tftp_args[0]
            tftp_port = int(tftp_args[1])
        else:
            print ('ERROR: %s is not a valid argument for --external-tftp'
                    % args.external_tftp)
            sys.exit(1)
        controller.set_external_tftp_server(tftp_address, tftp_port)
    else:
        controller.set_internal_tftp_server()


def add_targets(controller, args):
    """add targets to controller"""
    # Get a list of hosts
    hosts = []
    for entry in args.hostname.split(','):
        hosts.extend(parse_host_entry(entry))

    # Add hosts to controller
    if args.all_nodes:
        if controller.add_fabrics(hosts, args.user, args.password):
            print "ERROR: Failed to get IP info from all hosts. Aborting."
            print
            sys.exit(1)
    else:
        for host in hosts:
            controller.add_target(host, args.user, args.password)


def parse_host_entry(entry, hostfiles=set()):
    """parse a host entry"""
    try:
        return parse_hostfile_entry(entry, hostfiles)
    except ValueError:
        try:
            return parse_ip_range_entry(entry)
        except ValueError:
            return [entry]


def parse_hostfile_entry(entry, hostfiles=set()):
    """parse a hostfile entry, returning a list of hosts"""
    if entry.startswith('file='):
        filename = entry[5:]
    elif entry.startswith('hostfile='):
        filename = entry[9:]
    else:
        raise ValueError('%s is not a hostfile entry' % entry)

    if filename in hostfiles:
        return []
    hostfiles.add(filename)

    entries = []
    try:
        for line in open(filename):
            for element in line.partition('#')[0].split():
                for hostfile_entry in element.split(','):
                    entries.extend(parse_host_entry(hostfile_entry, hostfiles))
    except IOError:
        print 'ERROR: %s is not a valid hostfile entry' % entry
        sys.exit(1)

    return entries


def parse_ip_range_entry(entry):
    """ Get a list of ip addresses in a given range"""
    try:
        start, end = entry.split('-')

        # Convert start address to int
        start_bytes = map(int, start.split('.'))
        start_i = ((start_bytes[0] << 24) | (start_bytes[1] << 16)
                | (start_bytes[2] << 8) | (start_bytes[3]))

        # Convert end address to int
        end_bytes = map(int, end.split('.'))
        end_i = ((end_bytes[0] << 24) | (end_bytes[1] << 16)
                | (end_bytes[2] << 8) | (end_bytes[3]))

        # Get ip addresses in range
        addresses = []
        for i in range(start_i, end_i + 1):
            address_bytes = [(i >> (24 - 8 * x)) & 0xff for x in range(4)]
            addresses.append('%i.%i.%i.%i' % tuple(address_bytes))

    except (ValueError, IndexError):
        raise ValueError('%s is not an IP range' % entry)

    return addresses


def power_command(controller, args):
    """change the power state of a cluster or host"""

    # power policy
    if args.power_mode == 'policy':
        if args.policy == 'status':
            return controller.power_policy_status()
        else:
            return controller.power_policy(args.policy)

    # power status
    elif args.power_mode == 'status':
        return controller.power_status()

    # power on/off/reset
    else:
        return controller.power(args.power_mode)


def mcreset_command(controller, args):
    """reset the management controllers of a cluster or host"""
    return controller.mc_reset()


def fwupdate_command(controller, args):
    """update firmware on a cluster or host"""
    simg = None
    if args.force_simg:
        simg = False
    elif args.skip_simg:
        simg = True

    # Add image
    controller.add_image(args.filename, args.image_type,
            simg, args.version, args.daddr, args.skip_crc32)

    # Print all_nodes warning/confirmation
    if not args.all_nodes:
        sys.stdout.write('WARNING: Updating firmware without --all-nodes is dangerous.')
        if args.force_yes:
            sys.stdout.write('\n\n')
            sys.stdout.flush()
        else:
            sys.stdout.write(' Continue? (y/n) ')
            sys.stdout.flush()
            while True:
                command = raw_input().strip().lower()
                if command in ['y', 'yes']:
                    print
                    break
                elif command in ['n', 'no']:
                    return 1

    # Do firmware update
    return controller.update_firmware(args.partition)


def fwinfo_command(controller, args):
    """print firmware info"""
    return controller.firmware_info()


def sensor_command(controller, args):
    """read sensor values from a cluster or host"""
    sensor_name = args.sensor_name
    if sensor_name.lower() == 'list':
        sensor_name = ''

    return controller.get_sensors(sensor_name)


def ipinfo_command(controller, args):
    """get ip info from a cluster or host"""
    return controller.get_ipinfo()


def macaddrs_command(controller, args):
    """get mac addresses from a cluster or host"""
    return controller.get_macaddrs()


def config_reset_command(controller, args):
    """reset to factory default settings"""
    return controller.config_reset()


def config_boot_command(controller, args):
    """set A9 boot order"""
    if args.boot_order == 'status':
        return controller.config_boot_status()
    elif args.boot_order == 'none':
        return controller.config_boot([])
    else:
        return controller.config_boot(args.boot_order.split(','))


def info_command(controller, args):
    """print info from a cluster or host"""
    if args.info_type in [None, 'basic']:
        return controller.info_basic()
    elif args.info_type == 'ubootenv':
        return controller.info_ubootenv()
    elif args.info_type == 'dump':
        return controller.info_dump()
    else:
        return True


def ipmitool_command(controller, args):
    """run arbitrary ipmitool command"""
    if args.lanplus:
        ipmitool_args = ['-I', 'lanplus'] + args.ipmitool_args
    else:
        ipmitool_args = args.ipmitool_args

    return controller.ipmitool_command(ipmitool_args)


if __name__ == '__main__':
    main()
